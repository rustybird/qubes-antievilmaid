#!/bin/sh -e

. anti-evil-maid-lib
LABEL_SUFFIX_CHARS=0-9a-zA-Z=.-
BOOT_DIR=/boot
GRUB_DIR=$BOOT_DIR/grub2
GRUB_CFG=$GRUB_DIR/grub.cfg


usage() {
    cat <<END

Usage:
  anti-evil-maid-install [-s <suffix>] [-F] [-m] [-M <device>] [-S <suffix>] <device>

  Installs Anti Evil Maid to your system's boot partition, or to a different
  storage device (e.g. an SD card or a USB stick).


Arguments:
  -s: <device> gets labeled "$LABEL_PREFIX<suffix>"

      <suffix> can be composed of 0-13 characters from the alphabet $LABEL_SUFFIX_CHARS
      It defaults to <device>'s current suffix, if any, or the empty string
      otherwise. Each of your AEM installations must have a unique suffix.

      This suffix has no particular meaning, except that you can let it end in
      .rm=1 or .rm=0 to hint that <device> is removable or fixed, respectively,
      no matter what the Linux kernel detects.

  -F: passed on to mkfs.ext4 (don't ask for confirmation, etc.)

  -m: set up a multi-factor auth AEM media (EXPERIMENTAL)
      Using time-based one time password and a LUKS key file, provides resistance
      to shoulder surfing and video surveillance based passphrase snooping.

  -M: split multi-factor AEM (key file on separate media); implies "-m"
      Slightly increases resistance to multi-stage evil maid attacks.

  -S: label suffix for split multi-factor AEM device
      Same semantics as the "-s" argument listed above, except the length
      limit is 0-7 characters here.


Examples:
  Install on the system's boot partition (assuming that it is /dev/sda1), and
  label its current filesystem "$LABEL_PREFIX":

    anti-evil-maid-install /dev/sda1

  Install on an SD card's first partition, replacing its data with a new ext4
  filesystem labeled "$LABEL_PREFIX.sd", and make it bootable:

    anti-evil-maid-install -s .sd /dev/mmcblk0p1

  Install 2FA-enabled AEM on USB stick's first partition, overwriting it with
  a new ext4 filesystem and marking it bootable:

    anti-evil-maid-install -m /dev/sdb1

  Same as above, but storing LUKS key file on a separate USB stick (/dev/sdc1):

    anti-evil-maid-install -M /dev/sdc1 /dev/sdb1

END

    exit 1
}


# check invocation

alias mfa=false
unset LABEL_SUFFIX F SPLIT_DEV SPLIT_LABEL_SUFFIX
while getopts s:FhmM:S: opt; do
    case "$opt" in
        s) LABEL_SUFFIX=$OPTARG ;;
        F) F=-F ;;
        m) alias mfa=true ;;
        M) alias mfa=true; SPLIT_DEV=$OPTARG ;;
        S) SPLIT_LABEL_SUFFIX=$OPTARG ;;
        *) usage ;;
    esac
done

case "$LABEL_SUFFIX" in *[!$LABEL_SUFFIX_CHARS]*|??????????????*) usage; esac
LABEL=$LABEL_PREFIX$LABEL_SUFFIX

case "$SPLIT_LABEL_SUFFIX" in *[!$LABEL_SUFFIX_CHARS]*|????????*) usage; esac
SPLIT_LABEL=$SPLIT_LABEL_PREFIX$SPLIT_LABEL_SUFFIX

shift $(($OPTIND - 1))
case $# in
    1) PART_DEV=$1 ;;
    *) usage ;;
esac

if [ "$(id -ur)" != 0 ]; then
    log "This command must be run as root!"
    exit 1
fi

if [ -z "$(getluksuuids)" ]; then
    log "Anti Evil Maid requires encrypted disk!"
    exit 1
fi


# examine device

BOOT_MAJMIN=$(mountpoint -d "$BOOT_DIR") || BOOT_MAJMIN=
PART_DEV_MAJMIN=$(lsblk -dnr -o MAJ:MIN "$PART_DEV")

if external "$PART_DEV" && [ "$BOOT_MAJMIN" != "$PART_DEV_MAJMIN" ]; then
    alias replace=true
else
    alias replace=false
fi

WHOLE_DEV=$(lsblk -dnp -o PKNAME "$PART_DEV")
if ! [ -b "$WHOLE_DEV" -a "$WHOLE_DEV" != "$PART_DEV" ]; then
    log "Couldn't find parent device: $WHOLE_DEV"
    exit 1
fi

PART_DEV_REAL=$(readlink -f "$PART_DEV")
PART_NUM=${PART_DEV_REAL##*[!0-9]}
if ! [ "$PART_NUM" -gt 0 ]; then
    log "Couldn't extract partition number: $PART_NUM"
    exit 1
fi


# MFA-specific checks

if mfa && ! external "$PART_DEV"; then
    log "MFA-enabled AEM cannot be installed on the same storage device as Qubes OS."
    exit 1
elif mfa && ! removable "$PART_DEV" "$LABEL" ; then
    log "MFA-enabled AEM can only be used with removable media."
    log "Should the device be, in fact, removable (autodetection failed),"
    log "add '.rm=1' at the end of disk label suffix using the '-s' option."
    exit 1
fi


# examine split-MFA device

if [ -n "$SPLIT_DEV" ]; then
    SPLIT_WHOLE_DEV=$(lsblk -dnp -o PKNAME "$SPLIT_DEV")
    if ! [ -b "$SPLIT_WHOLE_DEV" -a "$SPLIT_WHOLE_DEV" != "$SPLIT_DEV" ]; then
        log "Couldn't find parent device: $SPLIT_WHOLE_DEV"
        exit 1
    fi

    SPLIT_PART_DEV_REAL=$(readlink -f "$SPLIT_DEV")
    SPLIT_PART_NUM=${SPLIT_PART_DEV_REAL##*[!0-9]}
    if ! [ "$SPLIT_PART_NUM" -gt 0 ]; then
        log "Couldn't extract partition number: $SPLIT_PART_NUM"
        exit 1
    fi

    if ! external "$SPLIT_DEV"; then
        log "Split-MFA cannot be installed on the same storage device as Qubes OS."
        exit 1
    elif ! removable "$SPLIT_DEV" "$SPLIT_LABEL"; then
        log "Split-MFA can only be used with removable media."
        log "Should the device be, in fact, removable (autodetection failed),"
        log "add '.rm=1' at the end of disk label suffix using the '-S' option."
        exit 1
    fi
fi


# This check (instead of a more obvious 'mountpoint $BOOT_DIR') should work
# even in unusual setups without any internal boot partition at all:

if [ ! -e "$GRUB_CFG" ]; then
    log "Couldn't find boot files at $BOOT_DIR"
    exit 1
fi


# keep old label unless overridden explicitly

OLD_LABEL=$(lsblk -dnr -o LABEL "$PART_DEV") ||
OLD_LABEL=

case "$OLD_LABEL" in "$LABEL_PREFIX"*)
    if [ -z "${LABEL_SUFFIX+set}" ]; then
        LABEL=$OLD_LABEL
    fi
esac


# split-MFA label keeper
if [ -n "$SPLIT_DEV" ]; then
    OLD_SPLIT_LABEL=$(lsblk -dnr -o LABEL "$SPLIT_DEV") ||
    OLD_SPLIT_LABEL=

    case "$OLD_SPLIT_LABEL" in "$SPLIT_LABEL_PREFIX"*)
        if [ -z "${SPLIT_LABEL_SUFFIX+set}" ]; then
            SPLIT_LABEL=$OLD_SPLIT_LABEL
        fi
    esac
fi


# create and/or label fs

if replace; then
    log "Creating new ext4 filesystem labeled $LABEL"
    mkfs.ext4 $F -L "$LABEL" "$PART_DEV"
else
    log "Labeling filesystem $LABEL"
    e2label "$PART_DEV" "$LABEL"
fi


# always recreate split-MFA FS

if [ -n "$SPLIT_DEV" ]; then
    log "Creating new ext4 filesystem labeled $SPLIT_LABEL"
    mkfs.ext4 $F -L "$SPLIT_LABEL" "$SPLIT_DEV"
fi


# move secrets if label changed

if [   -n "$OLD_LABEL" -a \
       -e "$AEM_DIR/$OLD_LABEL" -a \
     ! -e "$AEM_DIR/$LABEL" ]; then
    mv -v "$AEM_DIR/$OLD_LABEL" "$AEM_DIR/$LABEL"
fi


# MFA: generate a TOTP seed

if mfa && [ ! -e "$AEM_DIR/$LABEL/secret.otp" ]; then
    log "Generating new 160-bit TOTP seed"
    mkdir -p "$AEM_DIR/$LABEL"
    # TODO: Fedora 23 does not include base32 binary in coreutils
    # package, use python's base64 module as a workaround until
    # dom0 is upgraded to Fedora 24+. Afterwards, simply replace
    # the `python3 ...` line with `base32 -w 0 \`
    # (don't forget to remove python3 from spec file and AEM
    # dracut module requires & add base32 binary to initramfs)
    head -c 20 /dev/random \
        | python3 -c 'import sys,base64;print(base64.b32encode(sys.stdin.buffer.read()).decode("ascii"))' \
        | tr -d '=' \
        > "$AEM_DIR/$LABEL/secret.otp"

    # construct OTP URI
    otp_label="Qubes%20OS%3A%20Anti%20Evil%20Maid"
    otp_secret="$(cat "$AEM_DIR/$LABEL/secret.otp")"
    otp_uri="otpauth://totp/${otp_label}?secret=${otp_secret}"

    # create an ANSI text QR code and show it in the terminal
    # TODO: current qrencode version's ansiutf8 output has a
    # small cosmetic bug whereas it outputs an extra row of
    # pixels (the QR code still works just fine). Plain ansi
    # may be selected as a workaround, but results in a much
    # larger QR code which might scroll off in the terminal
    # emulator.
    echo "$otp_uri" | qrencode -t ansiutf8

    # show QR code
    log "Please scan the above QR code with your OTP device."

    # display the text form of secret to user, too
    human_readable_secret="$(echo "$otp_secret" | sed 's/\(....\)/\1\ /g')"
    log "Alternatively, you may manually enter the following secret into"
    log "your OTP device:"
    log "    $human_readable_secret"

    if timedatectl status | grep -q 'RTC in local TZ: yes'; then
        log ""
        log "WARNING: Your computer's RTC (real-time clock) is set to"
        log "store time in local timezone. This will cause wrong TOTP"
        log "codes to be generated during AEM boot. Please fix this by"
        log "running (as root):"
        log "    timedatectl set-local-rtc 0"
    fi

    # check whether secret was provisioned correctly
    log ""
    log "After you have set up your OTP device, please enter the code"
    log "displayed on your device and press <ENTER> to continue."
    log ""

    totp_tries=3
    for try in $(seq $totp_tries); do
        read -p "Code: "
        if ! oathtool --totp -b "$otp_secret" "$REPLY" >/dev/null; then
            log "Entered TOTP code is invalid!"
            if [ "$try" -lt $totp_tries ]; then
                log "Please check clock synchronization."
                log "If you made a mistake while manually entering the secret,"
                log "remove the added token, repeat the process and try again."
                log ""
            else
                log "Aborting AEM setup..."
                exit 1
            fi
        else
            break
        fi
    done

    log "TOTP code matches, continuing AEM setup."
fi

# MFA: generate and enroll a LUKS key file if not already present

if mfa; then
    if [ -n "$SPLIT_DEV" ]; then
        KEY_PATH="$AEM_DIR/$SPLIT_LABEL/secret.key"
        echo "$SPLIT_LABEL" > "$AEM_DIR/$LABEL/split-mfa.label"
    else
        KEY_PATH="$AEM_DIR/$LABEL/secret.key"
    fi

    if [ ! -e "$KEY_PATH" ]; then
        log "Generating new LUKS key file"
        rawkey=$(mktemp)
        head -c 64 /dev/random > "$rawkey"

        log "Encrypting key file"
        mkdir -p "$(dirname "$KEY_PATH")"
        scrypt enc "$rawkey" "$KEY_PATH"

        for dev in $(getluksuuids); do
            devname=$(readlink -f "/dev/disk/by-uuid/$dev")

            # check if LUKS device has any free key slots
            # FIXME: possibility of failing due to i18n?
            if ! cryptsetup luksDump "/dev/disk/by-uuid/$dev" \
                    | grep -q DISABLED; then
                log "FATAL: Device $devname (UUID $dev) has no free key slots!"
                exit 1
            fi

            log "Adding key file to new key slot for $devname (UUID $dev)"
            for try in 1 2 3; do
                if cryptsetup luksAddKey "/dev/disk/by-uuid/$dev" "$rawkey"; then
                    break
                elif [ $try -eq 3 ]; then
                    log "ERROR: Wrong password, aborting!"
                    log "You need to manually finish enrolling $rawkey"
                    log "as a key file for all desired LUKS devices, then"
                    log "remove the $rawkey file and re-run this script."
                    exit 1
                fi
            done
        done

        log "Shredding the unencrypted key file"
        shred -zu "$rawkey"
    fi
fi


# mount

if CUR_MNT=$(devtomnt "$PART_DEV") && [ -n "$CUR_MNT" ]; then
    PART_MNT=$CUR_MNT
else
    CUR_MNT=
    PART_MNT=/mnt/anti-evil-maid/$LABEL

    log "Mounting at $PART_MNT"
    mkdir -p "$PART_MNT"
    mount "$PART_DEV" "$PART_MNT"
fi


# mount split-MFA (cannot be already mounted since we always reformat)
if mfa && [ -n "$SPLIT_DEV" ]; then
    SPLIT_MNT=/mnt/anti-evil-maid/$SPLIT_LABEL
    log "Mounting split-MFA at $SPLIT_MNT"
    mkdir -p "$SPLIT_MNT"
    mount "$SPLIT_DEV" "$SPLIT_MNT"
fi


# sync

mkdir -p "$PART_MNT/aem"
synctpms "$LABEL" "$PART_MNT"
mkdir -p "$AEM_DIR/$LABEL"

if mfa && [ -n "$SPLIT_DEV" ]; then
    # store split-MFA label on first AEM dev
    cp "$AEM_DIR/$LABEL/split-mfa.label" "$PART_MNT/aem/"
fi

# sync split-MFA

if mfa && [ -n "$SPLIT_DEV" ]; then
    mkdir -p "$SPLIT_MNT/aem"
    synctpms "$SPLIT_LABEL" "$SPLIT_MNT"
    # mkdir -p "$AEM_DIR/$SPLIT_LABEL" not needed here
fi


# make device bootable

if replace; then
    log "Setting bootable flag"
    parted -s "$WHOLE_DEV" set "$PART_NUM" boot on

    log "Copying boot files"
    find "$BOOT_DIR" -maxdepth 1 -type f ! -name 'initramfs-*.img' \
         -exec cp {} "$PART_MNT" \;

    # TODO: If dracut is configured for no-hostonly mode (so we don't have to
    # worry about picking up loaded kernel modules), just copy each initramfs
    # instead of regenerating it
    for img in "$BOOT_DIR"/initramfs-*.img; do
        ver=${img%.img}
        ver=${ver##*initramfs-}
        log "Generating initramfs for kernel $ver"
        dracut --force "$PART_MNT/${img##*/}" "$ver"
    done

    log "Copying GRUB themes"
    dst=$PART_MNT/${GRUB_DIR#$BOOT_DIR/}
    mkdir "$dst"
    cp -r "$GRUB_DIR/themes" "$dst"

    log "Installing GRUB"
    grub2-install --boot-directory="$PART_MNT" "$WHOLE_DEV"

    log "Bind mounting $PART_MNT at $BOOT_DIR"
    mount --bind "$PART_MNT" "$BOOT_DIR"

    log "Generating GRUB configuration"
    grub2-mkconfig -o "$GRUB_CFG"

    log "Unmounting bind mounted $BOOT_DIR"
    umount "$BOOT_DIR"
fi


if [ -z "$CUR_MNT" ]; then
    log "Unmounting $PART_MNT"
    umount "$PART_MNT"
fi

if mfa && [ -n "$SPLIT_DEV" ]; then
    log "Unmounting $SPLIT_DEV"
    umount "$SPLIT_DEV"
fi
